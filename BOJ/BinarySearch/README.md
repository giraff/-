# 이분 탐색 / 삼분 탐색 (6문제)

11/7(월) ~ 11/ 7(월)

### 선형 탐색 vs. 이분 탐색

```jsx
선형 탐색 : 리스트 안 특정 데이터를 찾기 위해 앞에서부터 하나하나 데이터 탐색
이진 탐색 : 이미 '정렬된' 배열에서 탐색 범위를 좁혀가며 데이터를 탐색
-> 시작점, 끝점, 중간점을 이용하여 탐색 범위 설정
```

### 이진 탐색의 시간 복잡도 : **logN**

- 탐색 범위를 절반씩 줄여나가기 때문이다.

### 이진 탐색 pseudo code (1) 재귀

```jsx
function binarySearch(Arr, target, start, end) 
	if start > end: // 시작점과 끝점이 교차되면?
		return none // 찾고자 하는 값 없음
	
	mid = Math.floor((start + end) / 2) // mid는 start와 end의 중간 지점
	
	if(Arr[mid] === target): 
		return mid; // 찾고자 하는 값이 mid에 위치하면 위치값 mid 반환
	else if(Arr[mid] > target): // 찾고자 하는 값이 mid에 위치하는 값보다 작으면?
		return binarySearch(Arr, target, start, mid - 1) // 보다 작은 쪽으로 범위 조정
	else: // 찾고자 하는 값이 mid에 위치하는 값보다 크면?
		return binarySerach(Arr, target, mid + 1, end) // 보다 큰 쪽으로 범위 조정
```

### 이진 탐색 pseudo code (2) 반복문

```jsx
function binarySearch(Arr, target)
	start = 0
	end = Arr.length - 1

	while(start <= end): 
		mid = Math.floor((start + end) / 2)
		if Arr[mid] === target:
			return mid
		else if Arr[mid] > target:
			end = mid - 1
		else:
			start = mid + 1
	return none

```

### 이진 탐색 활용 (1) 파라메트릭 서치

최적화 문제를 바로 해결하기 어려운 경우, 결정 문제(예 / 아니오 ⇒ 이진 탐색)로 바꾸어 해결하는 기법

ex) 특정한 조정을 만족하는 가장 알맞은 값을 빠르게 찾는 문제

```jsx
1. 적절한 높이를 찾을 때 까지 이진 탐색을 수행하여 높이 H를 조정한다.
2. 현재 이 높이는 자르면 조건을 만족할 수 있는가? 를 확인한 후에 조건의 만족 여부에 따라 탐색 범위를 좁힐 수 있다.
=> **결정 문제** (예 / 아니오, 0 / 1)
3. 절단기의 높이는 0부터 10억까지의 정수 중 하나이다. 
**=> 이렇게 '큰 탐색 범위'를 가지면 가장 먼저 이진 탐색을 떠올려야 한다.**
```

---

**1654 랜선 자르기 : 파라메트릭 서치**

- 풀이
    
    ```jsx
    문제
    집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 
    박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.
    
    이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다.
    박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 
    예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)
    
    편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 
    그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 
    이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.
    
    입력
    첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. 
    K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 
    그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 
    랜선의 길이는 231-1보다 작거나 같은 자연수이다.
    4 11
    802
    743
    457
    539
    
    출력
    첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.
    200
    
    802cm 랜선에서 4개, 743cm 랜선에서 3개, 457cm 랜선에서 2개, 539cm 랜선에서 2개를 잘라내 모두 11개를 만들 수 있다.
    ```
    
    - 쪼갰을 때 모든 랜선의 개수가 11개 이상이어야 한다. 그걸 체크하면서 이진탐색을 하자.
    
    ```jsx
    const [input, ...tc] = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
    
    let [K, N] = input.split(' ').map(v => +v); 
    
    let result = 0;
    
    let start = 0; // 시작점
    let end = Math.max(...tc); // 끝 점 (길이 최댓값)
    
    while(start <= end):
    	let total = 0;
    	mid = Math.floor((start + end) / 2);
    	// 같은 길이의 랜선의 갯수 구해서 total에 더하기
    	tc.forEach((item) => {
    		total += Math.floor(item / mid);
    	})
    	
    	if total < N:
    		end = mid - 1; 
    	else
    		result = mid
    		start = mid + 1
    
    console.log(result);
    ```
    
---
**2805 나무 자르기 :: 파라메트릭 서치**

- 풀이
    
    ```jsx
    상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 
    정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다.
    
    목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 
    높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 
    그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 
    따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 
    예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 
    나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 
    상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 
    절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.
    
    상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 
    이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.
    
    입력
    첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)
    
    둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.
    
    출력
    적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.
    
    예제 입력 1 
    4 7
    20 15 10 17
    예제 출력 1 
    15
    예제 입력 2 
    5 20
    4 42 40 26 46
    예제 출력 2 
    36
    ```
    
    ```jsx
    const [first, second] = require('fs')
    .readFileSync('/dev/stdin').toString().trim().split('\n');
    
    let [N,M] = first.split(' ').map(v => +v);
    let trees = second.split(' ').map(v => +v);
    
    let start = 0; // 시작점
    let end = Math.max(...trees) // 끝점 (나무의 최대 길이)
    
    let result = 0; // 최대 길이를 저장할 공간
    // 이진 탐색
    while(start <= end) {
    	let total = 0;
    	let mid = Math.floor((start + end) / 2); // start와 end의 중간 지점 설정
    	
    	trees.forEach((item) => {
    		if(item > mid) { 
    			total += item - mid // 트리의 길이가 mid보다 크면 잘려진 길이 total에 더함
    		}
    	})
    	if(total < M) { // 요구하는 트리의 갯수보다 작다면 더 높이를 낮게 설정
    		end = mid - 1;
    	} else { // 요구하는 트리의 개수를 충족하거나 그 이상이면 높이를 더 높게 하고 result에 기록
    		result = mid; // 최대한 절단기를 높게, 자르는 게 목적이므로 일단 그것을 충족한 경우 기록
    		start = mid + 1;
    	}
    }
    
    console.log(result); // result 출력
    ```
    
---
2110 공유기 설치 :: 파라메트릭 서치 ← 집들 사이의 거리를 기준으로 이진탐색하기

- 풀이
    
    ```jsx
    도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 
    집 여러개가 같은 좌표를 가지는 일은 없다.
    
    도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 
    최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 
    가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.
    
    C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.
    
    입력
    첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 
    둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.
    
    출력
    첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.
    
    예제 입력 1 
    5 3
    1
    2
    8
    4
    9
    ```
    
    공유기 갯수가 2개이면? 시작점, 끝점 1가지 경우만 있다. (시작점과 끝점 사이 거리를 구하면 됨)
    
    공유기 갯수가 3개이면? 시작점 끝점 그리고 중간점 (mid)를 설정하여 중간점에 가장 가까운 집에 설치한다.
    
    이 문제는 파라메트릭 서치 알고리즘을 적용한다
    
    사실상 단순 이분 탐색 응용 문제이다
    
    문제가 원하는 것은 가장 인접한 두 공유기 사이의 거리가 최대이길 원한다
    
    **이것은 모든 공유기들 사이 간격(집 사이 간격)이 공평하기를 바라는 것을 의미한다고 볼 수 있다.**
    
    **따라서 집들 사이의 거리를 기준으로 이분 탐색이 진행되어야 한다.**
    
    1 2 4 8 9 가 있다고 할 때 공유기 사이의 최소, 최대 거리는 다음과 같다.
    
    ```jsx
    input = 1 2 4 8 9
    
    min = 1
    
    max = 9 - 1 = 8
    ```
    
    이러한 경우를 찾기 위해서 순수하게 생각하면 공유기간의 간격(min - max), 즉 각 간격을 기준으로 모든 집 좌표들을 확인해보면 된다. 하지만 이건 비효율적이다.
    
    각 간격을 기준으로 일일이 확인하는 것이 아닌 이분탐색의 방식을 이용한다.
    
    1. 특정 간격을 기준으로 가능한 위치에 공유기를 설치한다
    2. 설치한 후에는, 공유기가 더 설치되어야 할 때 간격을 줄인다.
    3. 공유기 수가 더 줄어들어야 한다면 간격을 늘린다.
    
    따라서 알고리즘은 아래와 같다.
    
    1. 주어진 집들의 좌표를 정렬해준다.
    2. 최소 거리는 1, 최대 거리는 처음 집과 마지막 집 사이의 거리이다
    3. 이분 탐색을 진행하면서 해당 간격(mid)으로 공유기를 설치할 때 조건을 충족하는지 확인한다.
    4. 조건을 충족하는 거리 중 최대를 출력한다 (모든 공유기를 설치했을 때 가장 최대 거리)
    
    ```jsx
    let [first, ...tc] = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
    
    let [N, C] = first.split(' ').map(v => +v);
    let input = tc.map(v => +v).sort((a,b) => a-b); // 1. 주어진 집들 좌표 정렬
    
    start = 1; // 최소 간격 
    end = input[N-1] - input[0]; // 최대 간격: 끝집과 첫집 사이 거리
    d = 0; // 거리
    
    let result = 0;
    while(start <= end){
    	middle = Math.floor((start + end) / 2); // 기준
    	let min = input[0]; // 맨 첫집 좌표
    	let cnt = 1;
    
    	// 간격 d를 기준으로 공유기 설치
    	for(let i = 1; i < N; i++) {
    		d = input[i] - min;
    		if(middle <= d){ // 기준에 비해 두 공유기의 거리가 멀다면?
    			++cnt; // 공유기 설치
    			min = input[i];
    		} 
    	}
    
    	if(cnt >= C) {
    		// 공유기 제한 갯수 이상 사용했을 경우 -> 간격 넓혀서 더 적게 설치해보자
    		result = middle;
    		start = middle + 1;
    	} else {
    		// 공유기 제한 갯수 미만 사용했을 경우 -> 간격 좁혀서 더 많이 설치해보자
    		end = middle - 1;
    	}
    }
    	
    console.log(result);
    ```
    
---
10815 **숫자카드** : 파라메트릭 서치

- 풀이
    
    ```jsx
    문제
    숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 
    정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.
    
    입력
    첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 
    둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 
    두 숫자 카드에 같은 수가 적혀있는 경우는 없다.
    
    셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 
    넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 
    이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다
    
    출력
    첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.
    
    예제 입력 1 
    5
    6 3 2 10 -10
    8
    10 9 -5 2 3 4 5 -10
    예제 출력 1 
    1 0 0 1 1 0 0 1
    ```
    
    - M개의 정수에 대한 결과를 담을 수 있는 M 길이의 배열을 따로 생성한다.
    - 가지고 있는 숫자 카드를 정렬한 뒤에 제일 작은 수(0번째 인덱스 값)을 시작점, 제일 큰 수(arr.length - 1번째 인덱스 값)을 끝점으로 해두고 이진 탐색을 실행한다.
    - M개의 정수를 하나씩 방문하면서 이진 탐색 알고리즘을 실행시키고 탐색이 된다면 1, 아니라면 0을 저장한다.
    
    ```jsx
    const [first, second, third, forth] = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
    
    let cards = second.split(' ').map(v => +v).sort((a, b) => a - b); // memory 500,000 => NlogN
    let compare = forth.split(' ').map(v => +v); // 병렬 memory 500,000 / NlogN
    let result = Array.from({length: +third}, () => 0); // 병렬 memory 500,000
    => 메모리 제한 1,500,000B (1억 이하)
    
    // 이진 탐색 알고리즘 함수
    function binarySearch(Array, target) { // logN 알고리즘
    	let start = 0;
    	let end = Array.length;
    	while(start <= end) {
    		mid = Math.floor((start + end) / 2);
    		if(Array[mid] === target) {
    			return 1;
    		} else if(Array[mid] < target){
    			start = mid + 1;
    		} else {
    			end = mid - 1;
    		}
    	}
    	return 0;
    }
    
    // 배열을 하나씩 방문하면서 탐색한 결과를 저장
    compare.forEach((item, idx) => {
    	if(binarySearch(cards, item) === 1) {
    		result[idx] = 1
    	} 
    })
    
    console.log(result.join(' '));
    ```
    
    시간 복잡도 ⇒ NlogN
    
---
10816 **숫자카드2** :: 숫자 카드 1 업그레이드 버전 object 활용

- 풀이
    
    ```jsx
    문제
    숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 
    정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.
    
    입력
    첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 
    둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 
    숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.
    
    셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 
    넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 
    이 수는 공백으로 구분되어져 있다. 
    이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.
    
    출력
    첫째 줄에 입력으로 주어진 M개의 수에 대해서, 
    각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.
    
    예제 입력 1 
    10
    6 3 2 10 10 10 -10 -10 7 3
    8
    10 9 -5 2 3 4 5 -10
    예제 출력 1 
    3 0 0 1 2 0 0 2
    ```
    
    ```jsx
    const [first, second, third, forth] = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
    
    let cards = second.split(' ').map(v => +v).sort((a, b) => a - b); // NlogN
    let compare = forth.split(' ').map(v => +v);
    let result = Array.from({length: +third}, () => 0);
    
    let obj = {}; // 객체
    for(let i = 0; i < cards.length; i++) { // N 시간 복잡도
    	if(obj.hasOwnProperty(cards[i])) {
    		obj[cards[i]] = obj[cards[i]] + 1;
    	} else {
    		obj[cards[i]] = 1;
    	}
    }
    
    // 추가후 {2: 1, 3: 2, 6: 1, 7: 1, 10: 3, -10: 2}
    let K = Object.keys(obj).map(v => +v).sort((a,b) => a-b); // 키만 뽑아 정렬된 배열로 만들기
    
    function binarySearch(Array, target) { // logN 알고리즘
    	let start = 0;
    	let end = Array.length;
    
    	while(start <= end) {
    		mid = Math.floor((start + end) / 2);
    		if(Array[mid] === target) {
    			return 1;
    		} else if(Array[mid] < target){
    			start = mid + 1;
    		} else {
    			end = mid - 1;
    		}
    	}
    	return 0;
    }
    
    compare.forEach((item, idx) => {
    		if(binarySearch(K, item) === 1) {
    			result[idx] = obj[item];
    		} 
    });
    
    console.log(result.join(' '));
    ```
    
---
11662 민호와 강호 :: 삼분 탐색

- 생략
    
    ```jsx
    민호와 강호가 2차원 좌표 평면 위에 있다. 
    민호는 점 A(Ax, Ay)에서 점 B(Bx, By)를 향해 걸어가고 있고, 
    강호는 점 C(Cx, Cy)에서 점 D(Dx, Dy)를 향해 걸어가고 있다. 
    민호와 강호는 동시에 출발하고, 민호가 점 B에 도착하는 순간 강호도 점 D에 도착한다. 
    또, 두 사람은 항상 일정한 속도로 걸어간다. 두 사람의 거리가 가장 가까울 때, 거리를 구하는 프로그램을 작성하시오.
    
    두 점 (x1, y1), (x2, y2)사이의 거리는 \(\sqrt{(x2-x1)^2 + (y2-y1)^2}\) 이다.
    
    입력
    첫째 줄에 Ax, Ay, Bx, By, Cx, Cy, Dx, Dy가 주어진다. 입력으로 주어지는 모든 좌표는 0보다 크거나 같고, 10000보다 작거나 같은 정수이다.
    
    출력
    민호와 강호가 가장 가까웠을 때의 거리를 출력한다. 절대/상대 오차는 10-6까지 허용한다.
    
    예제 입력 1 
    0 0 1 1 2 2 3 3
    예제 출력 1 
    2.8284271247
    ```
    
    ```jsx
    
    ```
    

+) 떡볶이 떡 만들기 :: 파라메트릭 서치

```jsx
떡ㅂ볶이 떡을 만드는 날입니다. 재밌게도 떡의 길이는 일정하지 않습니다. 대신 한 봉지 안에 
들어가는 떡의 총 길이는 절단기로 잘라서 맞춰줍니다.
절단기에 높이(H)를 지정하면 떡을 한 번에 절단합니다. 
높이가 H보다 긴 떡은 H위의 부분이 잘릴 것이고 낮은 떡은 잘리지 않습니다.

예를 들어 높이가 19, 14, 10, 17인 떡이 나란히 있고 절단기 높이를 15로 해두면 
자른 뒤 떡의 높이는 15,14,10,15가 될 것입니다.
잘린 떡의 길이는 4 0 0 2 입니다 손님은 6만큼의 길이를 가져갑니다.

손님이 **요청한 총 길이가 M**일 때 적어도 M만큼의 떡을 얻기 위해 절단기에 설정할 수 있는
높이의 최댓값을 구하시오.

4 6
19 15 10 17
```

- 절단기의 높이가 높을 수록 잘린 떡의 길이는 작아지고 반대로 절단기 높이가 낮을 수록 떡의 길이는 커진다.
- 이런 문제는 잘린 떡의 길이를 확인해가면서 이진탐색을 이용하여 푼다.

```jsx
// n = 4, m = 6, Array = [19, 15, 10, 17] 이라고 하자
// 이진 탐색을 위한 시작점과 끝점
start = 0;
end = Math.max(Array); 

result = 0

// 이진 탐색(반복적)
while start <= end:
	total = 0
	mid = Math.floor((start + end) / 2)
	
	// 잘랐을 때의 떡의 양 계산
	Array.forEach((item) => {
		if item > mid:
			total += item - mid
	})

	// 떡의 양이 부족한 경우 더 많이 자르기 (왼쪽 부분 탐색)
	if total < m:
		end = mid - 1
	// 떡의 양이 충분한 경우 덜 자르기 (오른쪽 부분 탐색, 단 최대한 덜 잘랐을 때가 정답이므로 기록)
	else:
		result = mid 
		start = mid + 1
	// 딱 맞지 않을 수 있기 때문에 total < m 혹은 total >= 조건만 따진다.
print(result)
```

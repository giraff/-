# move zeros

배열을 바라보는 기본적인 시각을 길러주는 문제

**주어진 배열 안에서 0들을 전부 끝단으로 보내주세요.**

여기서 중요한 것은 0들이 끝으로 가는 도중에 중간 숫자들의 순서는 변하면 안 된다.

```javascript
/*
@input [0, 5, 0, 4, 0, 0, 7, 0]

@result [5, 4, 7, 0, 0, 0, 0, 0]
*/
```

- 직관적으로 드는 생각 1
  - 0을 if문으로 찾아서 오른쪽 끝으로 보내면 되겠지?
  - -> 그러면 숫자들을 한 칸씩 옆으로 밀어야 한다 (순서가 변하면 안되니까) 코드가 복잡해진다
- 직관적으로 드는 생각 2
  - 0을 찾아서 오른쪽으로 Bubble swap 하자
  - -> 그러면 간단한 코드로 구현은 가능하지만 시간 복잡도가 N^2 발생한다.

### idea

- 문제를 뒤집어서 **'0'** 을 찾아서 **'오른쪽'** 으로 보내는게 아니고 배열 중 **'0이 아닌 숫자'** 를 찾아서 **'왼쪽'** 으로 보낸다
  - 그러면 숫자만 찾아서 왼쪽으로 보내는 것이기 때문에 숫자의 순서가 변할 이유는 없다.

## 배열의 가장 기본적인 접근 방법 : index를 사용하자

- **0이 아닌 숫자를 찾아가는 주황색 인덱스** 와 **항상 0을 가리키는 파란색 인덱스** 를 정의하자

- 주황색 인덱스는 숫자를 찾게되고 숫자를 찾게되면 파란색 인덱스의 값과 swap -> 파란색 인덱스는 한 칸 올려주자.
- 주황색 인덱스는 0이 아닌 수를 찾게 될 때까지 한칸씩 진행한다.
- 또, 값을 찾으면 파란색 인덱스의 값과 swap하고 파란색 인덱스는 한 칸 올려주자
- 주황색 인덱스가 배열 끝단에 도착하면 반복문을 중단한다.
- 이제 이 순간부터 파란색 인덱스가 배열 끝단에 도착할 때 까지 모든 요소를 0으로 덮어씌워주자.

### 만약 둘 다 숫자를 가리키고 있으면?

숫자를 가리키고 있을 땐 둘이 같이 다음 인덱스로 이동한다.

- 이걸 swap의 개념으로 보지 않고 copy의 개념으로 보고 마지막 copy가 끝나면 0을 overwriting 한다 -> sliding

## 구현

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
  let onlyNums = 0; // 숫자만 찾아가는 인덱스
  let copyPosition = 0; // 숫자를 카피할 자리를 가리키는 인덱스

  // 숫자들을 순차적으로 배열 앞 쪽으로 복붙하기
  for (onlyNums = 0; onlyNums < nums.length; onlyNums++) {
    if (nums[onlyNums] !== 0) {
      nums[copyPosition] = nums[onlyNums];
      copyPosition++;
    }
  }

  // 나머지 배열들을 0으로 채우기
  for (let idx = copyPosition; idx < nums.length; idx++) {
    nums[idx] = 0;
  }
};
```

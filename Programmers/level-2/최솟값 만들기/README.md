## 풀이
case 1. array A = [a, a+i] , array B = [b, b+j] (i, j는 양수) 라고 가정하자

1) 둘다 오름차순 / 혹은 내림차순으로 정렬한뒤 각 원소 곱의 합
ab + (a+i)(b+j) = 2ab + aj + bi + ij

2) 한 배열은 오름차순 / 다른 배열은 내림차순으로 서로 다르게 정렬한 뒤 각 원소 곱의 합
a(b+j) + b(a+i) = 2ab + aj + bi


case 2. array A = [a, a+i, a+ki], array B = [b, b+j, b+tj] (i,j,k,t는 양수) 라고 가정하자

조합의 원칙때문에 각 원소의 곱의 합은 총 6가지 경우의 수가 나온다.

이때도 각 원소 곱의 합을 해봤을 때 한 쪽은 정렬을 오름차순, 한 쪽은 정렬을 내림차순으로 해서 큰 수 X 작은 수 가 되도록
하는 경우가 최솟값이 나왔다

그 이유는 정렬을 서로 같게 하거나 아무 규칙없이 랜덤으로 쌍을 지어 곱을 할 경우
큰 수 X 작은 수 규칙으로 할 때보다 훨씬 큰 수 조합이 1개 이상 나오기 때문이다.
(큰 수 X 작은 수 조합으로 하지 않고 다른 방법으로 할 경우 작은 수와 큰 수를 곱하지 않은 부분이 1개 이상 나온다 (큰 수 X 큰 수 조합이 무조건 나오게 되는데 이는 큰 수 X 작은 수 조합보다 필연적으로 커질 수 밖에 없다))

따라서 방법은 '한 배열은 오름차 순, 나머지 배열은 내림차순으로 정렬한 뒤 각 인덱스 값이 같은 원소끼리 곱하여 누적합을 구하기' 이다

## 풀이 2
- 배열 A 의 최댓값을 구한다, 동시에 B의 최솟값을 구한다.
- 두 수의 인덱스를 다른 변수에 저장해두고 두 수를 곱한 값을 누적합한다
- 두 수를 각 배열에서 삭제 시킨다 (배열 변형)
- 두 배열의 길이가 0이 될 때 까지 반복한다.
- 반복이 종료되고 남은 누적합한 변수 값이 두 배열의 원소간 곱의 누적합의 최솟값이 된다.
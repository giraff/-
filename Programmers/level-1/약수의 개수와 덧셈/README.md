# 약수, 소수 정리

### 소수란?

약수로 1과 자기자신을 가지는 수

- 1의 약수 : 1 -> 약수가 1개인 유일한 자연수 (소수가 아님)
- 2의 약수 : 1, 2 -> 유일한 짝수 소수, 가장 작은 소수
- 3의 약수 : 1, 3 -> 소수
- 4의 약수 : 1, 2, 4
- 5의 약수 : 1, 5 -> 소수

### 약수의 개수가 짝수

- 제곱근으로 나눈 값이 딱 떨어지지 않는다. === 제곱근이 실수이다.

### 약수의 개수가 홀수

=== 제곱근이 정수이다.

### 효율적으로 약수를 찾는 알고리즘

- 어떤 수의 N의 약수를 구할 때는 1부터 N의 제곱근까지의 수만 0으로 나누어 떨어지는지 확인하면 된다
  100 % 1, 100 % 2, 100% 4, 100 % 5 , 100 % 10,
- 1, 2, 4, 5, 10 을 구한 다음 100에 이미 구해진 1,2,4,5,10을 나누어 각각 20, 25, 50, 100을 구해낸다.
- 그 다음 중복을 제거하고, 오름차순으로 정렬.
- O(제곱근 N)인 알고리즘이다.

### 최대 공약수 - 유클리드 호제법, 인류 최초의 알고리즘

ex) 자연수 A, B 의 최대공약수를 구하시오

1. A를 B로 모듈러 연산을 한다 (A % B)
2. 만약 나머지가 0이라면 B가 최대공약수이다.
3. 만약 나머지가 0이 아니라면 A를 B로 바꾸고, B를 나머지로 바꾼다

- 위 세가지 단계를 계속 반복하면 된다.

### 유클리드 호제법 - 재귀 호출

```
int gcd (int a, int b) {
  return b ? gcd(b, a%b) : a;
}
```

### 유클리드 호제법 - 반복문

```
int gcd_recur(int a, int b) {
  while(true) {
    int c = a % b;
    if(c === 0) return b;
    a = b;
    b = c;
  }
}
```

### JS 실수이냐 정수이냐 판별

1. 모듈러스

```
num % 1 != 0
// 23 % 1 = 0
// 23.5 % 1 = 0.5
```

2. string.indexOf('.') === -1

3. Math.floor(num) === num
